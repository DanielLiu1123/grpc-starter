# Usage Guide

## Quick Start

### 1. Add Dependency

Add the grpc-client-processor dependency to your project:

```gradle
dependencies {
    implementation("io.github.danielliu1123:grpc-client-processor:${version}")
}
```

### 2. Scan and Generate Configuration

#### Programmatic Usage

```java
import grpcstarter.processor.GrpcClientProcessor;
import java.io.File;

public class GenerateConfig {
    public static void main(String[] args) throws Exception {
        GrpcClientProcessor processor = new GrpcClientProcessor();
        
        File outputFile = processor.process(
            new File("src/main/java"),           // output directory
            "com.example.config",                 // package name
            "GrpcClientConfiguration",            // class name
            "io.grpc", "com.example"             // packages to scan
        );
        
        System.out.println("Generated: " + outputFile);
    }
}
```

#### Command Line Usage

```bash
java -cp grpc-client-processor.jar grpcstarter.processor.GrpcClientProcessor \
    src/main/java \
    com.example.config \
    GrpcClientConfiguration \
    io.grpc com.example
```

### 3. Use Generated Configuration

The generated configuration will automatically register all gRPC client stubs as Spring beans:

```java
@SpringBootApplication
@Import(GrpcClientConfiguration.class)
public class Application {
    
    @Autowired
    private UserServiceBlockingStub userStub;
    
    @Autowired
    private OrderServiceStub orderStub;
    
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

## Advanced Usage

### Custom Authority

```java
GrpcClientProcessor processor = new GrpcClientProcessor("production.example.com:443");
processor.process(outputDir, packageName, className, basePackages);
```

### Generate as String

```java
GrpcClientProcessor processor = new GrpcClientProcessor();
String configCode = processor.processToString(
    "com.example.config",
    "GrpcClientConfiguration",
    "com.example.grpc"
);
System.out.println(configCode);
```

### Scan Specific Packages

```java
// Scan multiple packages
processor.process(
    outputDir,
    "com.example.config",
    "GrpcClientConfiguration",
    "io.grpc.testing",
    "com.example.user",
    "com.example.order"
);
```

## Generated Configuration Example

For a project with the following gRPC stubs:
- `UserServiceGrpc.UserServiceBlockingStub`
- `OrderServiceGrpc.OrderServiceStub`
- `ProductServiceGrpc.ProductServiceFutureStub`

The processor will generate:

```java
package com.example.config;

import io.grpc.Channel;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Lazy;
import jakarta.annotation.PreDestroy;

import com.example.UserServiceGrpc.UserServiceBlockingStub;
import com.example.OrderServiceGrpc.OrderServiceStub;
import com.example.ProductServiceGrpc.ProductServiceFutureStub;

/**
 * Auto-generated Spring Configuration for gRPC clients.
 * Generated by grpc-client-processor.
 */
@Configuration
public class GrpcClientConfiguration {

    private ManagedChannel channel;

    @Bean
    public ManagedChannel grpcChannel() {
        if (channel == null) {
            channel = ManagedChannelBuilder.forTarget("localhost:9090")
                    .usePlaintext()
                    .build();
        }
        return channel;
    }

    @Bean
    @Lazy
    public UserServiceBlockingStub userServiceBlockingStub(ManagedChannel channel) {
        return UserServiceGrpc.newBlockingStub(channel);
    }

    @Bean
    @Lazy
    public OrderServiceStub orderServiceStub(ManagedChannel channel) {
        return OrderServiceGrpc.newStub(channel);
    }

    @Bean
    @Lazy
    public ProductServiceFutureStub productServiceFutureStub(ManagedChannel channel) {
        return ProductServiceGrpc.newFutureStub(channel);
    }

    @PreDestroy
    public void shutdown() {
        if (channel != null && !channel.isShutdown()) {
            channel.shutdown();
        }
    }
}
```

## Integration with Build Tools

### Gradle Task

You can create a Gradle task to automatically generate the configuration:

```gradle
task generateGrpcClientConfig(type: JavaExec) {
    classpath = sourceSets.main.runtimeClasspath
    mainClass = 'grpcstarter.processor.GrpcClientProcessor'
    args = [
        'src/main/java',
        'com.example.config',
        'GrpcClientConfiguration',
        'io.grpc',
        'com.example'
    ]
}

compileJava.dependsOn generateGrpcClientConfig
```

### Maven Plugin

```xml
<plugin>
    <groupId>org.codehaus.mojo</groupId>
    <artifactId>exec-maven-plugin</artifactId>
    <version>3.1.0</version>
    <executions>
        <execution>
            <id>generate-grpc-config</id>
            <phase>generate-sources</phase>
            <goals>
                <goal>java</goal>
            </goals>
            <configuration>
                <mainClass>grpcstarter.processor.GrpcClientProcessor</mainClass>
                <arguments>
                    <argument>src/main/java</argument>
                    <argument>com.example.config</argument>
                    <argument>GrpcClientConfiguration</argument>
                    <argument>io.grpc</argument>
                    <argument>com.example</argument>
                </arguments>
            </configuration>
        </execution>
    </executions>
</plugin>
```

## Notes

- All generated client beans are marked with `@Lazy` to avoid unnecessary initialization
- The generated configuration includes a `@PreDestroy` method to properly shutdown the gRPC channel
- The scanner looks for classes that:
  - End with "Stub"
  - Extend `io.grpc.stub.AbstractStub`
- Supports all three types of gRPC stubs:
  - Blocking stubs (created with `newBlockingStub`)
  - Async stubs (created with `newStub`)
  - Future stubs (created with `newFutureStub`)

